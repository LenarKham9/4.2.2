# 4.2.2
Тест, который будет авторизовываться, создавать бронь
Вынесем base_url и headers в отдельный файл constant.py

Вынесем метод get_token и инициализацию сессии в отдельную фикстуру в отдельном файле conftest.py
- Декоратор **`@pytest.fixture(scope="session")`** определяет фикстуру, которая будет создана один раз для всех тестов в сессии.
- **`session = requests.Session()` с**оздает объект сессии **`requests`**, который позволяет сохранять cookies и заголовки между запросами.
- **`session.headers.update(HEADERS)`** Устанавливает необходимые заголовки (например, **`Content-Type`** и **`Accept`**) для всех запросов в сессии.
- Отправляет POST запрос на эндпоинт **`/auth`** для авторизации и извлекает токен из ответа.
- **`session.headers.update({"Cookie": f"token={token}"})`** Добавляет токен авторизации в заголовки сессии, что позволяет авторизовываться на сервере в последующих запросах.
- **`return session`** Возвращает объект сессии, который затем используется в тестах для выполнения запросов с авторизацией.

  Вынесем booking_data в фикстуру, добавив рандомизацию данных, во избежания парадокса пестецида
  - **`@pytest.fixture()`**: Определяет функцию как фикстуру pytest, которая может быть использована в тестах. Без указания **`scope`**, фикстура по умолчанию будет создаваться заново для каждого теста, где она используется.
- **Возвращаемый объект**: Функция возвращает словарь с данными для создания букинга. Эти данные включают имя, фамилию, общую стоимость, статус оплаты депозита, даты заезда и выезда, а также дополнительные потребности.
- **`fake.first_name()`, `fake.last_name()`**: Генерируют случайные имя и фамилию.
- **`fake.random_int(min=100, max=10000)`**: Генерирует случайное число в заданном диапазоне, используемое как общая стоимость букинга.

  1. **Использование фикстур**: В параметрах функции теста указаны **`booking_data`** и **`auth_session`.** Это ****означает, что **`pytest`** автоматически предоставит данные для букинга и объект авторизованной сессии перед выполнением теста. Эти фикстуры упрощают подготовку тестового окружения и делают код более чистым и понятным.
2. **Создание букинга**: Сначала тест делает POST-запрос на создание букинга, используя **`auth_session`** для отправки запроса с необходимыми заголовками авторизации и **`booking_data`** для передачи данных букинга. Проверяется, что статус ответа равен 200, что указывает на успешное создание букинга. Затем из ответа извлекается **`booking_id`**, который используется для дальнейших запросов.
3. **Проверка данных букинга**: Затем тест делает GET-запрос, чтобы получить информацию о созданном букинге, используя **`booking_id`**. Проверяется, что статус ответа также равен 200. Далее тест сравнивает данные из ответа с исходными данными, отправленными при создании букинга, что позволяет удостовериться в корректности сохранения данных.
4. **Удаление букинга**: После проверки данных тест выполняет запрос на удаление букинга, используя его **`booking_id`**. Проверяется статус код ответа на запрос удаления. Код 201 укажет на успешное выполнение операции.
5. **Проверка удаления букинга**: В конце тест выполняет ещё один GET-запрос, пытаясь получить информацию о только что удаленном букинге. Ожидается получение статуса 404, что подтверждает, что букинг действительно был удален.

Использование **`auth_session`** для отправки запросов гарантирует, что все **запросы** автоматически **включают** необходимые **заголовки авторизации**; **упрощает** **структуру** теста и **избавляет от необходимости** каждый раз явно **указывать заголовки**.

Далее:
Тест на обновление бронирования (PUT), в котором обновляются данные и проверяются
Тест на частичное обновление бронирования (PATCH)
Тест на получение бронирования по ID
Тест на попытку получения несуществующего бронирования
Тест на создание бронирования с неполными данными
Тест на обновление бронирования без авторизации
